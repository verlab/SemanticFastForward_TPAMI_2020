%> @file video_features_frames.m
%>
%> Functions to create the video frames representation based on Movement, Appearance, Semantic Information, and yolo description over the frames.
%> 
%> Function call:
%> @code
%> [ videoFeatures , optical_flow_features ] = video_features_frames( videoFilename , ofFilename , semanticFilename , yoloDescFilename)
%> @endcode

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   This file is part of SparseSampling@TPAMI2020.
%
%    SparseSampling@TPAMI2020 is free software: you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation, either version 3 of the License, or
%    (at your option) any later version.
%
%    SparseSampling@TPAMI2020 is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with SparseSampling@TPAMI2020.  If not, see <http://www.gnu.org/licenses/>.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ========================================================================
%> @brief Calculate the video features based on video to create the SC dictionary. 
%>
%> The features are already balanced using whitening.
%>
%> @param videoFilename    - @c string , complete path and filename with extension to the video.
%> @param ofFilename       - @c string , complete path and filename with extension to the CSV file with the Optical flow calculate by Poleg et al. 2014.
%> @param semanticFilename - @c string , complete path and filename with extension to the MAT file generated by the semantic extractor function.
%> @param yoloDescFilename - @c string , complete path and filename with extension to the CSV file generated by the CNN YOLO semantic extractor.
%>
%> @retval video_features        - VF x W @c double , features of each frame of the vide in the format of a matrix of dimensions OF 349d ( 50 Magnitude histogram + 72 Orientation histogram + 144 Color moments + 3 Semantics + 80 YOLO outputs ) by W (num. frames).
%> @retval optical_flow_features - OF x W @c double , optical flow features of each frame of the vide in the format of dimensions OF 349d ( 25 X axis Optical Flow + 25 Y axis Optical Flow ) by W (num. frames).
%>
%> @author Michel M. Silva (michelms@dcc.ufmg.br)
%>
%> @date 21/08/2017 
% ========================================================================
function [ videoFeatures , optical_flow_features ] = video_features_frames( videoFilename , ofFilename , semanticFilename , yoloDescFilename)
   
     semanticFeatures = get_semantic_features_frames( semanticFilename , yoloDescFilename);
     [ movementFeatures , optical_flow_features ] = get_movement_features( ofFilename );
     
     nFrames = size( semanticFeatures , 2 );
     appearanceFeatures = get_appearance_features( videoFilename , nFrames );
     
     movementFeatures = [movementFeatures zeros(size(movementFeatures,1),nFrames-size(movementFeatures,2))];
     optical_flow_features = [optical_flow_features zeros(size(optical_flow_features,1),nFrames-size(optical_flow_features,2))];
     
     %appearanceFeatures = appearanceFeatures(:,size(semanticFeatures,1));
     videoFeatures = [movementFeatures; appearanceFeatures; semanticFeatures ];
     videoFeatures = whitening_matrix(videoFeatures')';

end

 
% ========================================================================
%> @brief Calculate the appearance features of the video frames.
%>
%> @param videoFilename - @c string , complete path and filename with extension to the video.
%> @param nFrames       - @c int    , number of frames of the video.
%>
%> @retval apperanceFeatures - F x N @c double , matrix with dimensions F ( 144 : mean, std, skewness for each HSV channels in a 4x4 window chain ) by N (number of frames).
%>
%> @author Michel M. Silva (michelms@dcc.ufmg.br)
%>
%> @date 21/08/2017 
% ========================================================================
function [ appearance_features ] = get_appearance_features ( videoFilename , nFrames )

    % Open video.
    fprintf('\n\n %s[I] --> Reading video...', log_line_prefix);
    video = VideoReader(videoFilename);
    fprintf('\n\n %s[I] --> Video ready!', log_line_prefix);
         
    appearance_features = zeros(144, nFrames);

    i = 1;
    
    fprintf('\n\n %s[I] --> Processing... \n\n', log_line_prefix);
    
    % Appearance features.
    while hasFrame( video )
                
        frame = readFrame( video );

        moments = color_moments_feature (frame, 4, 4);
        
        appearance_features(:, i) =  moments ;

        progress_bar(i, nFrames);
        i = i + 1;

    end    

end

% ========================================================================
%> @brief Calculates the color moment based on HSV color space in each block of the image.
%>
%> @param image   - m x n @c double , input image in a matrix format with dimensions m (width) by n (height).
%> @param blocksX - @c int          , horizontal image chain divisions.
%> @param blocksY - @c int          , vertical image chain divisions.
%>
%> @retval colorMoments    - 1 x ( 9 * blocksX * block * Y) @c double , matrix with 3 first color moments from each H, S, V channel of each block for each frame.
%>
%> @author Michel M. Silva (michelms@dcc.ufmg.br)
%>
%> @date 28/03/2017 
% ========================================================================
function [ colorMoments ] = color_moments_feature (image, blocksX, blocksY)

    % convert to HSV
    image = rgb2hsv(image);

    colorMoments = zeros( 9*blocksX*blocksY , 1 );
    counter = 1;

    for i=1:blocksX
        for j=1:blocksY
            
            % extract color channels
            H = double(image((size(image, 1)*(i-1)/blocksX)+1:size(image, 1)*i/blocksX, (size(image, 2)*(j-1)/blocksY)+1:size(image, 2)*j/blocksY, 1));
            S = double(image((size(image, 1)*(i-1)/blocksX)+1:size(image, 1)*i/blocksX, (size(image, 2)*(j-1)/blocksY)+1:size(image, 2)*j/blocksY, 2));
            V = double(image((size(image, 1)*(i-1)/blocksX)+1:size(image, 1)*i/blocksX, (size(image, 2)*(j-1)/blocksY)+1:size(image, 2)*j/blocksY, 3));

            % compute 3 first color moments from each channel
            meanH = mean( H(:) );
            stdH  = std( H(:) );
            skewH = skewness( H(:) , 0 );

            meanS = mean( S(:) );
            stdS  = std( S(:) );
            skewS = skewness( S(:) , 0 );

            meanV = mean( V(:) );
            stdV  = std( V(:) );
            skewV = skewness( V(:) , 0 );
            
            if isnan(skewH)
                skewH = 0;
            end
            
            if isnan(skewS)
                skewS = 0;
            end
            
            if isnan(skewV)
                skewV = 0;
            end
            
            % construct output vector
            colorMoments(((counter-1)*9)+1:counter*9 , 1) = [meanH stdH skewH meanS stdS skewS meanV stdV skewV];
            counter = counter + 1;
        end

        % clear('H', 'S', 'V', 'meanH', 'stdH', 'skewH', 'meanS', 'stdS', 'skewS', 'meanV', 'stdV', 'skewV');

    end
end

% ========================================================================
%> @brief Calculate the video appearance features based on the color histogram into a image chain division.
%>
%> @param image   - m x n @c double , image in matrix format with dimensions m (width) by n (height).
%> @param blocksX - @c int          , number of horizontal blocks.
%> @param blocksY - @c int          , number of vertic
%>
%> @retval emdHistogramsFeatures - 1 x (blocksX * blocksY) @c double , vector containing the Color Histogram of each block in the image.
%>
%> @author Michel M. Silva (michelms@dcc.ufmg.br)
%>
%> @date 28/03/2017 
% ========================================================================
function [ colorHistogramsFeatures ] = color_histograms_feature( image, blocksX, blocksY )

    colorHistogramsFeatures = zeros( blocksX * blocksY, 1 );
    
    histogramNumBins = 256;

    for i=1:blocksX
        for j=1:blocksY

            % extract color channels
            image_1_block = double(image( (size(image, 1)*(i-1)/blocksX)+1:size(image, 1)*i/blocksX, (size(image, 2)*(j-1)/blocksY)+1:size(image, 2)*j/blocksY , : ));
                                   
            image_1_H(:,1) = imhist( image_1_block(:,:,1) , histogramNumBins);
            image_1_H(:,2) = imhist( image_1_block(:,:,2) , histogramNumBins);
            image_1_H(:,3) = imhist( image_1_block(:,:,3) , histogramNumBins);

            image_1_H = image_1_H / numel(image_1_block(:,:,1));

            colorHistogramsFeatures(blocksY*(i-1)+j) = sum(sum(abs(cumsum(image_1_H) - cumsum(image_2_H))));
            
        end
    end

end

% ========================================================================
%> @brief Calculate the video appearance features based on Earth Movers Distance over the color histograms of consecutive images.
%> 
%> @param image1  - m x n @c double , first image in matrix format with dimensions m (width) by n (height).
%> @param image2  - m x n @c double , second image in matrix format with dimensions m (width) by n (height).
%> @param blocksX - @c int          , number of horizontal blocks.
%> @param blocksY - @c int          , number of vertical blocks.
%>
%> @retval emdHistogramsFeatures - 1 x (blocksX * blocksY) @c double, vector containing the Earth Mover Distance between each block in the first and second image.
%>
%> @author Michel M. Silva (michelms@dcc.ufmg.br)
%>
%> @date 28/03/2017
% ========================================================================
function [ emdHistogramsFeatures ] = emd_histograms_feature( image1, image2, blocksX, blocksY )

    emdHistogramsFeatures = zeros( blocksX * blocksY, 1 );
    
    histogramNumBins = 256;

    for i=1:blocksX
        for j=1:blocksY

            % extract color channels
            image_1_block = double(image1( (size(image1, 1)*(i-1)/blocksX)+1:size(image1, 1)*i/blocksX, (size(image1, 2)*(j-1)/blocksY)+1:size(image1, 2)*j/blocksY , : ));
            image_2_block = double(image2( (size(image2, 1)*(i-1)/blocksX)+1:size(image2, 1)*i/blocksX, (size(image2, 2)*(j-1)/blocksY)+1:size(image2, 2)*j/blocksY , : ));
                                   
            image_1_H(:,1) = imhist( image_1_block(:,:,1) , histogramNumBins);
            image_1_H(:,2) = imhist( image_1_block(:,:,2) , histogramNumBins);
            image_1_H(:,3) = imhist( image_1_block(:,:,3) , histogramNumBins);

            image_2_H(:,1) = imhist( image_2_block(:,:,1) , histogramNumBins);
            image_2_H(:,2) = imhist( image_2_block(:,:,2) , histogramNumBins);
            image_2_H(:,3) = imhist( image_2_block(:,:,3) , histogramNumBins);


            image_1_H = image_1_H / numel(image_1_block(:,:,1));
            image_2_H = image_2_H / numel(image_2_block(:,:,1));

            emdHistogramsFeatures(blocksY*(i-1)+j) = sum(sum(abs(cumsum(image_1_H) - cumsum(image_2_H))));
            
        end
    end

end

%% --- Movement Features -----------------------------------------------------------------------------------

% ========================================================================
%> @brief Calculate the video movement features based on the estimation of Optical Flow using the Vid2OpticalFlow over the video images.
%> 
%> @param ofFilename - @c string , complete path with filename and extension to the CSV file generated by the Vid2OpticalFlow.
%> 
%> @retval movement_features     - VF x W @c double , movement histogram features in a matrix format with dimensions VF ( 122 : 50 Magnitude histogram + 72 Orientation histogram) by W (number of frames of the video).
%> @retval optical_flow_features - OF x W @c double , optical flow features of each frame of the vide in a matrix format of dimensions OF 349d ( 25 X axis Optical Flow + 25 Y axis Optical Flow ) by W (num. frames).
%>
%> @author Michel M. Silva (michelms@dcc.ufmg.br)
%>
%> @date 18/08/2017
% ========================================================================
function [ movement_features , optical_flow_features ] = get_movement_features( ofFilename )

    vidData = read_load_LK_from_Vid2OpticalFlowCSV(ofFilename);
    x_displacements = vidData.LK_X;
    y_displacements = vidData.LK_Y;
    
    optical_flow_features = [ x_displacements ; y_displacements ];
    optical_flow_features = [ optical_flow_features , zeros(size(optical_flow_features, 1),1) ];
    [magHist, oriHist ] = calculate_OF_histograms( optical_flow_features' );      
    
    movement_features = [ magHist'; oriHist' ];

end

% ========================================================================
%> @brief Load the informations from a Vid2OpticalFlowCSV file to a MATLAB variable.
%> 
%> Available informations:
%> - vidData.num_frames 
%> - vidData.width 
%> - vidData.height
%> - vidData.num_x_cells
%> - vidData.num_y_cells
%> - vidData.skip
%> - vidData.csv_fname
%> - vidData.frame_range
%> - vidData.num_blocks
%> - vidData.LK_X
%> - vidData.LK_Y
%> - vidData.fps
%> 
%> @param vidCSVfilename - @c string , complete path with filename and extension to the CSV file generated by the Vid2OpticalFlow.
%> 
%> @retval vidData       - @c struct , a matlab struct containing the informations extract from the video by the Vid2OpticalFlow.
%>
%> @author Y. Poleg 
%>
% ========================================================================
function [ vidData ] = read_load_LK_from_Vid2OpticalFlowCSV(vidCSVfilename)
    % POLEG processing functions bellow, don't touch

    metadata = read_Vid2OpticalFlow_metadata(vidCSVfilename);

    lkcsv=csvread(vidCSVfilename,1,0);
    numFrames = size(lkcsv,1);
    xblocks = str2double(metadata('NUM_BLOCKS_X'));
    yblocks = str2double(metadata('NUM_BLOCKS_Y'));
    blockwidth = str2double(metadata('BLOCK_WIDTH'));
    blockheight = str2double(metadata('BLOCK_HEIGHT'));

    processing_width = str2double(metadata('PROCESSING_WIDTH'));
    processing_height = str2double(metadata('PROCESSING_HEIGHT'));

    numBlocks = xblocks*yblocks;
    sframe = str2double(metadata('START_FRAME'));
    eframe = str2double(metadata('END_FRAME'));
    skip = str2double(metadata('FRAME_SKIP'))+1;
    frame_range = sframe:skip:eframe;
    frame_range = frame_range(1:numFrames);

    X = zeros(numBlocks,numFrames);
    Y = zeros(numBlocks,numFrames);

    t=0;
    for yb=1:yblocks
        for xb=1:xblocks
            t=t+1;

            % Each LK block data is composed of six elements: valid,x,y,sum_canny,num_fpoints,backproj_err. The valid
            % vector is 0 if the result is invalid and 1 if it is valid.
            ind = 1+(t-1)*6; % Ind to the first column of the current block (Matlab is 1 based).

            valid = lkcsv(:,ind);
            x = lkcsv(:,ind+1);
            y = lkcsv(:,ind+2);


            % suppress large motions that dont make sense
            max_valid_x = min([blockwidth 50]);
            max_valid_y = min([blockheight 50]);
            valid = valid .* (abs(x)<max_valid_x);
            valid = valid .* (abs(y)<max_valid_y);

            % Need at least two points to interpolate missing data...
            if sum(valid) > 2

                % Set invalid points to nan
                invalid_logical = valid==0;

                if sum(invalid_logical)>0

                    x(invalid_logical) = interp1(frame_range(~invalid_logical),x(~invalid_logical),frame_range(invalid_logical));
                    y(invalid_logical) = interp1(frame_range(~invalid_logical),y(~invalid_logical),frame_range(invalid_logical));

                    % Handle nans on boundaries...
                    if isnan(x(1)) || isnan(x(end))
                        temp=find(~isnan(x));
                        if numel(temp)>0
                            first_not_nan=temp(1);
                            x(1:first_not_nan-1) = x(first_not_nan);
                            y(1:first_not_nan-1) = y(first_not_nan);
                            last_not_nan=temp(end);
                            x(last_not_nan+1:end) = x(last_not_nan);
                            y(last_not_nan+1:end) = y(last_not_nan);
                        else
                            % Entire block is nan??
                        end
                    end
                end
            else
                % This block is entirely invalid.
                x(:) = 0;
                y(:) = 0;
            end

            X(t,:) = x;
            Y(t,:) = y;

        end
    end

    vidData.num_frames = numFrames;
    vidData.width = processing_width;
    vidData.height = processing_height;
    vidData.num_x_cells = xblocks;
    vidData.num_y_cells = yblocks;
    vidData.skip = skip;
    vidData.csv_fname = vidCSVfilename;
    vidData.frame_range = frame_range;
    vidData.num_blocks = numBlocks;
    vidData.LK_X = X ./ vidData.width; % Normalize to image size.
    vidData.LK_Y = Y ./ vidData.height;
    vidData.fps = str2double(metadata('FPS'));

end

% ========================================================================
%> @brief Read the informations from a Vid2OpticalFlowCSV file.
%>  
%> @param lkCSVfilename - @c string , complete path with filename and extension to the CSV file generated by the Vid2OpticalFlow.
%> 
%> @retval metadata - MATLAB variable , a matlab variable containing the informations loaded from the file generated by the Vid2OpticalFlow.
%>
%> @author Y. Poleg 
%>
% ========================================================================
function [ metadata ] = read_Vid2OpticalFlow_metadata(lkCSVfilename)
    % POLEG processing functions bellow, don't touch

    fileID = fopen(lkCSVfilename);
    line = textscan(fileID, '%s',1,'Delimiter','\n');
    fclose(fileID);

    line = cell2mat(line{1});
    [pairs] = textscan(line,'%s','Delimiter',',');

    metadata = containers.Map();

    for i=1:numel(pairs{1})
        [kvpair] = textscan(pairs{1}{i},'%s','Delimiter','=');
        metadata(kvpair{1}{1}) = kvpair{1}{2};
    end
end

% ========================================================================
%> @brief Calculate the  the informations from a Vid2OpticalFlowCSV file.
%>  
%> @param descriptor - N x F @c double , OF descriptor matrix with dimensions N ( video number frames ) by F ( 50 : 25 OF_x + 25 OF_y).
%> 
%> @retval magHist - N X Fmag @c double , Histogram of magnitude in a matrix format with dimensions N ( video number frames ) by Fmag ( 50 bins ) .
%> @retval oriHist - N X Fori @c double , Histogram of orientations in a matrix format with dimensions N ( video number frames ) by Fori ( 72 bins ) .
%>
%> @author Felipe C. Chamone (cadar@dcc.ufmg.br)
%>
%> @date 18/08/2017
% ========================================================================
function [ magHist, oriHist ] = calculate_OF_histograms( descriptor )

    framecount = size(descriptor, 1);
    V = [1 0 0];
    
    OFx = descriptor(:, 1:25);
    OFy = descriptor(:, 26:end);
       
    OFmagnitude = zeros(framecount, 25);
    OForientation = zeros(framecount, 25);
    
    %calc each magnitude and orientation
    for i=1:framecount   
       for j=1:25
           OFmagnitude(i, j) = sqrt((OFx(i,j)^2) + (OFy(i,j)^2));
           U = [OFx(i,j) OFy(i,j) 0];
           angle = atan2d(norm(cross(U,V)),dot(U,V));
           if (U(2)> 0)
               OForientation(i,j) = angle;
           else
               OForientation(i,j) = 360 - angle;
           end
       end      
    end

    %compute histogram edges
    [h1, MagEdges] = histcounts(OFmagnitude, 50);
    [h2, OriEdges] = histcounts(OForientation, 72);

    magHist = zeros(framecount, size(h1,2));
    oriHist = zeros(framecount, size(h2,2));
    
%     disp(MagEdges);
    
    %compute each histogram
    for i=1:framecount
        magHist(i,:) = histcounts(OFmagnitude(i, :), MagEdges);
        oriHist(i,:) = histcounts(OForientation(i, :), OriEdges);
    end
end


%% --- Semantic Features -----------------------------------------------------------------------------------

% ========================================================================
%> @brief calculates the semantic features in a frame-wise operation mode.
%>
%> @param semanticFilename - @c string , complete path and filename with extension to the MAT file generated by the semantic extractor function.
%> @param yoloDescFilename - @c string , complete path and filename with extension to the CSV output file generated by the CNN YOLO semantic extractor.
%>
%> @retval semanticFeatures - 3 x n @c double , matrix with dimensions 83 ( total semantic value, number of semantic objects, average total value per number of semantic objects, YOLO output) x n (number of frames in the video).
%>
%> @author Michel M. Silva (michelms@dcc.ufmg.br)
%>
%> @date 06/04/2017 
% ========================================================================
function [ semanticFeatures ] = get_semantic_features_frames( semanticFilename , yoloDescFilename )


    semantic = load(semanticFilename);
    nframes = length(semantic.Rects);
    
    semanticFeatures = zeros(83,nframes);
            
    for i = 1:nframes
        
        nRects = size(semantic.Rects{i},2);
        totalValue = 0;
        meanValue = 0;
        
        if nRects > 0
        
            for j = 1:nRects            
                totalValue = totalValue + (semantic.Rects{i}(j).score * semantic.Rects{i}(j).faceSizeValue * semantic.Rects{i}(j).gaussianWeight);            
            end

            meanValue = totalValue/nRects;
            
        end
        
        semanticFeatures(81:83,i) = [totalValue; nRects; meanValue];
                
    end
    
    yoloFeatures = csvread(yoloDescFilename);
    
    semanticFeatures = [semanticFeatures zeros(size(yoloFeatures, 2)+3, size(yoloFeatures,1)-nframes)];
    
    semanticFeatures(1:80,:) = yoloFeatures';  

end
